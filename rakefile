# coding: utf-8
require 'yaml'
require 'json'
require 'tempfile'
require 'pathname'

begin
  require 'term/ansicolor'
  include Term::ANSIColor
rescue LoadError
  raise 'Run "gem install term-ansicolor"'
end

BASE_PORT = 4101
MIN_NPM_VERSION = "1.1.18"
MIN_GEM_VERSION = "1.8.23"
LOCAL_DOMAIN = "binaryage.org"

ROOT = File.expand_path('.')
WWW = File.join(ROOT, 'www')
BLOG = File.join(ROOT, 'blog')
SUPPORT = File.join(ROOT, 'support')
TOTALFINDER = File.join(ROOT, 'totalfinder-web')
TOTALTERMINAL = File.join(ROOT, 'totalterminal-web')
TOTALSPACES = File.join(ROOT, 'totalspaces-web')
ASEPSIS = File.join(ROOT, 'asepsis-web')
VISOR = File.join(ROOT, 'visor')
FIREQUERY = File.join(ROOT, 'firequery')
FIRERAINBOW = File.join(ROOT, 'firerainbow')
FIRELOGGER = File.join(ROOT, 'firelogger')
DRYDROP = File.join(ROOT, 'drydrop')
XREFRESH = File.join(ROOT, 'xrefresh')
HINTS = File.join(ROOT, 'hints')
RESTATIC = File.join(ROOT, 'restatic-web')
TESTWEB = File.join(ROOT, 'test-web')

TEMP_DIR = "/tmp/binaryage-site"

def extract_name(path)
  name = (path.split("/"))[-1] # get last component of the path
end

def subdomain(path)
  name = extract_name(path)
  name.split("-")[0] # strips -web postfixes
end


$master = WWW # this repo will hold real submodule "shared", slaves will hard-link them
$slaves = [TESTWEB, BLOG, SUPPORT, VISOR, TOTALFINDER, TOTALSPACES, FIREQUERY, FIRELOGGER, FIRERAINBOW, DRYDROP, XREFRESH, TOTALTERMINAL, ASEPSIS, HINTS, RESTATIC]
$all = [$master].concat $slaves
$all_domains = $all.collect {|x| subdomain(x)}
$all_names = $all.collect {|x| extract_name(x)}

def file_color(text); yellow(text); end
def dir_color(text); blue(text); end
def cmd_color(text); green(text); end

def die(msg, code=1)
  puts red(msg)
  exit(code)
end

def sys(cmd)
  puts blue("> "+cmd)
  if not system(cmd) then
    die "something went wrong"
  end
end

def port_for_domain(domain)
  BASE_PORT + $all_domains.index(domain)
end

def path_for_domain(domain)
  $all[$all_domains.index(domain)]
end

def require_rmagick!
  begin
    require 'rmagick'
    include Magick
  rescue LoadError
    raise 'You must "sudo gem install rmagick"'
  end
end

# prevents git error message:
# You can't push to git://github.com/darwin/site.git
# Use git@github.com:darwin/site.git
def get_writable_git_url()
  `git remote show origin | grep "Fetch URL:"`.strip =~ /Fetch URL:\s*(.*)/

  if $1.nil?
    puts "unable to parse: #{res} (ouput from: git remote show origin | grep \"Fetch URL:\")"
    exit 2
  end

  $1.sub("git://", "git@").sub("github.com/", "github.com:")
end

def prepare_patched_jekyll_config(dev_mode=false)
  begin
    config = YAML.load_file('_config.yml')
  rescue => err
    config = {}
  end

  config["layouts"] = "shared/layouts"
  config["plugins"] = "../.jekyll-plugins"
  config["stylus"] = {
    "compress" => true,
    "path" => "./shared/css/site.styl"
  }
  config["combinejs"] = {
    "path" => "./shared/js/code.list",
    "minify" => (not dev_mode)
  }
  config["html_press"] = {
    "compress" => (not dev_mode)
  }

  temp_config = Tempfile.new('jekyll_config.yml')
  temp_config.write(YAML.dump(config))
  temp_config.close

  Pathname.new(temp_config.path).relative_path_from(Pathname.new Dir.pwd)
end

################################################################################

desc "install npm dependencies"
task :init_npm do
  die "install npm (>=v#{MIN_NPM_VERSION}) => http://npmjs.org" unless Gem::Version.new(`npm --version`) >= Gem::Version.new(MIN_NPM_VERSION)
  sys("npm install")
end

desc "install gem dependencies"
task :init_gem do
  die "install rubygems (>=v#{MIN_GEM_VERSION}, no sudo, consider rvm) => http://rubygems.org, http://beginrescueend.com" unless Gem::Version.new(`gem --version`) >= Gem::Version.new(MIN_GEM_VERSION)
  sys("bundle install")
end

desc "init repositories - needs special care"
task :init => [:init_gem, :init_npm] do
  sys("git remote set-url --push origin #{get_writable_git_url()}")
  sys("git submodule update --init")

  # fix push urls
  $all.each do |repo|
    Dir.chdir(repo) do
      sys("git remote set-url --push origin #{get_writable_git_url()}")
    end
  end

  # cleanup submodules
  $slaves.each do |slave|
    sys("rm -rf \"#{slave}/shared\"")
  end

  # download submodules into master repo
  Dir.chdir($master) do
    sys("git submodule update --init")
    # fix push url in submodule
    Dir.chdir("shared") do
      sys("git remote set-url --push origin #{get_writable_git_url()}")
    end
  end

  # for each slave, "symlink" submodules from master repo
  $slaves.each do |slave|
    Dir.chdir(slave) do
      sys("git submodule init")
    end
    sys("rmdir \"#{slave}/shared\"") if File.directory?("#{slave}/shared")
    sys("./.bin/hlink/hlink \"#{$master}/shared\" \"#{slave}/shared\"")
  end
end

desc "reset to remote changes - this will destroy your local changes!!!"
task :reset do
  Dir.chdir($master) do
    puts "in #{yellow($master)}"
    sys("git checkout -f web")
    sys("git reset --hard HEAD^") # be resilient to amends
    sys("git clean -f -f -d") # http://stackoverflow.com/questions/9314365/git-clean-is-not-removing-a-submodule-added-to-a-branch-when-switching-branches
    sys("git pull origin web")
    ["shared"].each do |submodule|
      submodule = File.join($master, submodule)
      Dir.chdir(submodule) do
        puts "in #{yellow(submodule)}"
        sys("git checkout -f master")
        sys("git reset --hard HEAD^") # be resilient to amends
        sys("git clean -f -f -d") # http://stackoverflow.com/questions/9314365/git-clean-is-not-removing-a-submodule-added-to-a-branch-when-switching-branches
        sys("git pull origin master")
      end
    end
  end
  $slaves.each do |slave|
    Dir.chdir(slave) do
      puts "in #{yellow(slave)}"
      sys("git checkout -f web")
      sys("git reset --hard HEAD^") # be resilient to amends
      sys("git clean -f -f -d") # http://stackoverflow.com/questions/9314365/git-clean-is-not-removing-a-submodule-added-to-a-branch-when-switching-branches
      sys("git pull origin web")
    end
    # shared should be hard linked, so we got pull for free from master
  end
end

desc "prints info how to setup /etc/hosts"
task :hosts do
  puts "add this section into your /etc/hosts:"
  puts
  puts "#### #{LOCAL_DOMAIN} test site ####"
  $all_domains.each do |domain|
    puts "127.0.0.1 #{domain}.#{LOCAL_DOMAIN}"
  end
  puts "#### #{LOCAL_DOMAIN} test site ####"
end

desc "generate proxy config"
task :proxy_config do
  hash = {
    "host" => "localhost",
    "port" => 80,
    "hostnameOnly" => true,
    "router" => {
    }
  }

  $all_domains.each do |domain|
    port = port_for_domain(domain)
    hash["router"]["#{domain}.#{LOCAL_DOMAIN}"] = "127.0.0.1:#{port}"
  end
  puts JSON.pretty_generate(hash)
end

desc "run dev server"
task :serve do
  puts "note: make sure you have /etc/hosts properly configured, see> rake hosts"

  what = (ENV["what"] || $all_domains.join(",")).split(",")

  # run jekyll sites
  $all_domains.each do |domain|
    next unless what.include?(domain)
    path = path_for_domain(domain)
    port = port_for_domain(domain)
    Dir.chdir path do
      config = prepare_patched_jekyll_config(true) # dev mode
      work_dir = File.join(TEMP_DIR, "serve", domain)
      sys("mkdir -p \"#{work_dir}\"")
      sys("bundle exec jekyll --auto --server #{port} --url http://#{domain}.#{LOCAL_DOMAIN} --config \"#{config}\" \"#{work_dir}\" &")
    end
  end

  # run reverse proxy
  sys("rake -s proxy_config > .proxy.config")
  puts "Launching proxy server on port 80 (root needed)"
  puts "=> www.#{LOCAL_DOMAIN}, use CTRL^C to kill all"
  sys("sudo ./node_modules/.bin/node-http-proxy --config .proxy.config")

  # wait for signal and instantly kill all ofsprings
  # http://autonomousmachine.com/posts/2011/6/2/cleaning-up-processes-in-ruby
  trap("INT") do
    exit
  end
  Process.kill('INT', -Process.getpgrp)
end

def build_single_web(name, stage)
  domain = subdomain(name)

  sys("rm -rf \"#{stage}/_#{name}\"") # make it clean just for sure

  # build jekyll
  Dir.chdir name do
    config = prepare_patched_jekyll_config()
    sys("bundle exec jekyll --config \"#{config}\" \"#{stage}/_#{name}\"")
  end

  # sync static site to stage
  sys("mkdir -p \"#{stage}/#{name}\"")
  sys("cp -r \"#{stage}/_#{name}\"/* \"#{stage}/#{name}\"")
  sys("rm -rf \"#{stage}/_#{name}\"")
end

desc "build site"
task :build do
  what = (ENV["what"] || $all_domains.join(",")).split(",")
  stage = ENV["stage"] || File.join(ROOT, "stage")

  what.each do |web|
    build_single_web(web, stage)
  end
end

desc "force github pages update"
task :force do
  $slaves.each do |path|
    puts "in #{yellow(path)}"
    Dir.chdir(path) do
      `touch _force_github_pages_update_the_site`
      `git add .`
      `git commit -m "force github pages update the site"`
      `git push`
    end
  end
end

desc "push all"
task :push do
  $all.each do |path|
    puts "in #{yellow(path)}"
    Dir.chdir(path) do
      sys("git push origin web")
    end
  end
end

desc "upgrade submodule pointers"
task :upgrade do
  # better use: git submodule foreach 'cmds'
  $all.each do |path|
    puts "in #{yellow(path)}"
    Dir.chdir(path) do
       sys("git checkout web")
       sys("git commit -am \"update 404\"")
    end
  end
end

desc "convert pngs to loseless jpgs"
task :strip do
  require_rmagick!

  Dir.glob(File.join(WWW, 'shared', "img", "*.png")) do |file|
    next unless file =~ /body-repeat/
    puts file
    image = ImageList.new(file)
    image.strip!
    image.write(file) #{ self.quality = 100; }
  end
end

desc "convert pngs to loseless jpgs"
task :print do
  require_rmagick!

  Dir.glob(File.join(WWW, 'shared', "img", "*.png")) do |file|
    next unless file =~ /tabs-background/
    puts file

    img = Magick::Image::read(file).first
    puts "   Format: #{img.format}"
    puts "   Geometry: #{img.columns}x#{img.rows}"
    puts "   Class: " + case img.class_type
      when Magick::DirectClass
        "DirectClass"
      when Magick::PseudoClass
        "PseudoClass"
    end
    puts "   Depth: #{img.depth} bits-per-pixel"
    puts "   Colors: #{img.number_colors}"
    puts "   Filesize: #{img.filesize}"
    puts "   Resolution: #{img.x_resolution.to_i}x#{img.y_resolution.to_i} "+"pixels/#{img.units == Magick::PixelsPerInchResolution ? "inch" : "centimeter"}"
    if img.properties.length > 0
      puts "   Properties:"
      img.properties { |name,value| puts %Q|      #{name} = "#{value}"| }
    end
  end
end

desc "convert icons to other formats"
task :icons do
  require_rmagick!

  Dir.glob(File.join(WWW, 'shared', "img", "icons", "totalspaces-512.png")) do |file|
    puts file
    image = ImageList.new(file)

    file64 = file.gsub('512', '64')
    image64 = image.resize(64, 64)
    image64.write(file64)

    file128 = file.gsub('512', '128')
    image128 = image.resize(128, 128)
    image128.write(file128)

    file256 = file.gsub('512', '256')
    image256 = image.resize(256, 256)
    image256.write(file256)

    file512white = file.gsub('512', '512-white')
    bg = Image.new(image.columns, image.rows) {
      self.background_color = "white"
    }
    bg = bg.composite(image, CenterGravity, OverCompositeOp)
    bg.write(file512white)

    file256white = file.gsub('512', '256-white')
    bg = Image.new(image.columns, image.rows) {
      self.background_color = "white"
    }
    bg = bg.composite(image, CenterGravity, OverCompositeOp)
    bg = bg.resize(256, 256)
    bg.write(file256white)
  end
end

desc "optimize png images"
task :optimize do
  Dir.glob(File.join(WWW, 'shared', "**", "*.png")) do |file|
    puts file
    `optipng −i1 −o7 "#{file}"`
    break
  end
  Dir.glob(File.join(WWW, 'images', "**", "*.png")) do |file|
    puts file
    `optipng −i1 −o7 "#{file}"`
    break
  end
end

task :default => :serve