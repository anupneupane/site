# coding: utf-8

BASE_PORT = 4101
MIN_NPM_VERSION = "1.1.18"
MIN_GEM_VERSION = "1.8.23"
LOCAL_DOMAIN = "binaryage.org"

ROOT = File.expand_path('.')
WWW = File.join(ROOT, 'www')
BLOG = File.join(ROOT, 'blog')
SUPPORT = File.join(ROOT, 'support')
TOTALFINDER = File.join(ROOT, 'totalfinder-web')
TOTALTERMINAL = File.join(ROOT, 'totalterminal-web')
TOTALSPACES = File.join(ROOT, 'totalspaces-web')
ASEPSIS = File.join(ROOT, 'asepsis-web')
VISOR = File.join(ROOT, 'visor')
FIREQUERY = File.join(ROOT, 'firequery')
FIRERAINBOW = File.join(ROOT, 'firerainbow')
FIRELOGGER = File.join(ROOT, 'firelogger')
DRYDROP = File.join(ROOT, 'drydrop')
XREFRESH = File.join(ROOT, 'xrefresh')
HINTS = File.join(ROOT, 'hints')
RESTATIC = File.join(ROOT, 'restatic-web')

def subdomain(path)
  name = (path.split("/"))[-1] # get last component of the path
  name.split("-")[0] # strips -web postfixes
end

$master = WWW # this repo will hold real submodules _layouts and shared, slaves will hard-link them
$slaves = [BLOG, SUPPORT, VISOR, TOTALFINDER, TOTALSPACES, FIREQUERY, FIRELOGGER, FIRERAINBOW, DRYDROP, XREFRESH, TOTALTERMINAL, ASEPSIS, HINTS, RESTATIC]
$all = [$master].concat $slaves
$all_domains = $all.collect {|x| subdomain(x)}

require 'json'

begin
  require 'term/ansicolor'
  include Term::ANSIColor
rescue LoadError
  raise 'Run "gem install term-ansicolor"'
end

def file_color(text); yellow(text); end
def dir_color(text); blue(text); end
def cmd_color(text); green(text); end

def die(msg, code=1)
  puts red(msg)
  exit(code)
end

def sys(cmd)
  puts blue("> "+cmd)
  system(cmd)
end

def port_for_domain(domain)
  BASE_PORT + $all_domains.index(domain)
end

def path_for_domain(domain) 
  $all[$all_domains.index(domain)]
end

def require_rmagick!
  begin
    require 'rmagick'
    include Magick
  rescue LoadError
    raise 'You must "sudo gem install rmagick"'
  end
end

################################################################################

desc "install npm dependencies"
task :init_npm do
  die "install npm (>=v#{MIN_NPM_VERSION}) => http://npmjs.org" unless Gem::Version.new(`npm --version`) >= Gem::Version.new(MIN_NPM_VERSION)
  sys("npm install")
end

desc "install gem dependencies"
task :init_gem do
  die "install rubygems (>=v#{MIN_GEM_VERSION}, no sudo, consider rvm) => http://rubygems.org, http://beginrescueend.com" unless Gem::Version.new(`gem --version`) >= Gem::Version.new(MIN_GEM_VERSION)
  sys("gem install term-ansicolor")
end

desc "init repositories - needs special care"
task :init => [:init_gem, :init_npm] do
  sys("git submodule update --init")

  # cleanup subsubmodules
  $slaves.each do |slave|
    ["_layouts", "shared"].each do |submodule|
      sys("rm -rf \"#{slave}/#{submodule}\"")
    end
  end
  
  # download _layouts and shared submodule into master repo
  Dir.chdir($master) do
    sys("git checkout gh-pages")
    sys("git submodule update --init --recursive")
  end
  
  # for each slave, "symlink" _layouts and shared submodule from master repo
  $slaves.each do |slave|
    Dir.chdir(slave) do
      sys("git checkout gh-pages")
      sys("git submodule init")
    end
    ["_layouts", "shared"].each do |submodule|
      sys("rmdir \"#{slave}/#{submodule}\"") if File.directory?("#{slave}/#{submodule}")
      sys("./.bin/hlink/hlink \"#{$master}/#{submodule}\" \"#{slave}/#{submodule}\"")
    end
  end
end

desc "reset to remote changes - this will destroy your local changes!!!"
task :reset do
  Dir.chdir($master) do
    puts "in #{yellow($master)}"
    sys("git checkout -f gh-pages")
    sys("git reset --hard HEAD")
    sys("git clean -fd")
    sys("git pull")
    ["_layouts", "shared"].each do |submodule|
      submodule = File.join($master, submodule)
      Dir.chdir(submodule) do
        puts "in #{yellow(submodule)}"
        sys("git checkout -f master")
        sys("git reset --hard HEAD")
        sys("git clean -fd")
        sys("git pull")
      end
    end
  end
  $slaves.each do |slave|
    Dir.chdir(slave) do
      puts "in #{yellow(slave)}"
      sys("git checkout -f gh-pages")
      sys("git reset --hard HEAD")
      sys("git clean -fd")
      sys("git pull")
    end
    # _layouts and shared should by hard linked, so we got pull for free from master
  end
end

desc "prints info how to setup /etc/hosts"
task :hosts do
  puts "add this section into your /etc/hosts:"
  puts
  puts "#### #{LOCAL_DOMAIN} test site ####"
  $all_domains.each do |domain|
    puts "127.0.0.1 #{domain}.#{LOCAL_DOMAIN}"
  end
  puts "#### #{LOCAL_DOMAIN} test site ####"
end

desc "generate proxy config"
task :proxy_config do
  hash = {
    "host" => "localhost",
    "port" => 80,
    "hostnameOnly" => true,
    "router" => {
    }
  }
  
  $all_domains.each do |domain|
    port = port_for_domain(domain)
    hash["router"]["#{domain}.#{LOCAL_DOMAIN}"] = "127.0.0.1:#{port}"
  end
  puts JSON.pretty_generate(hash)
end

desc "run dev server"
task :serve do
  puts "note: make sure you have /etc/hosts properly configured, see> rake hosts"
  
  what = (ENV["what"] || $all_domains.join(",")).split(",")

  # run stylus
  sys("cd \"#{WWW}/shared/css\" && \"#{ROOT}/node_modules/.bin/stylus\" -w site2.styl &")
  sleep 2

  # run jekyll sites  
  $all_domains.each do |domain|
    path = path_for_domain(domain)
    port = port_for_domain(domain)
    sys("cd \"#{path}\" && jekyll --auto --server #{port} --url http://#{domain}.#{LOCAL_DOMAIN} &") if what.include?(domain)
  end
  sleep 8

  # run reverse proxy
  sys("rake -s proxy_config > .proxy.config")
  puts "Launching proxy server on port 80 (root needed)"
  sys("sudo ./node_modules/.bin/node-http-proxy --config .proxy.config &")
  
  # wait for signal and instantly kill all ofsprings
  # http://autonomousmachine.com/posts/2011/6/2/cleaning-up-processes-in-ruby
  trap("INT") do
    Process.kill('INT', -Process.getpgrp)    
    exit
  end
  puts "=> www.#{LOCAL_DOMAIN}, use CTRL^C to kill all"
  sleep 
end

def build_single_web(name)
  path = path_for_domain(name)

  # build stylus
  Dir.chdir "#{path}/shared/css" do
    sys("\"#{ROOT}/node_modules/.bin/stylus\" site2.styl")
  end

  # build jekyll
  Dir.chdir path do
    sys("jekyll --url http://#{name}.binaryage.com")
  end
  
  # sync static site to destination
  

end

desc "build site"
task :build do
  what = (ENV["what"] || $all_domains.join(",")).split(",")
  
  what.each do |web|
    build_single_web(web)
  end
end

desc "force github pages update"
task :force do
  $slaves.each do |path|
    puts "in #{yellow(path)}"
    layouts = File.join(path, "_layouts")
    shared = File.join(path, "shared")
    Dir.chdir(path) do
      `touch _force_github_pages_update_the_site`
      `git add .`
      `git commit -m "force github pages update the site"`
      `git push`
    end
  end
end

desc "push all"
task :push do
  $all.each do |path|
    puts "in #{yellow(path)}"
    Dir.chdir(path) do
      sys("git push")
    end
  end
end

desc "upgrade submodule pointers"
task :upgrade do
  # better use: git submodule foreach 'cmds'
  $all.each do |path|
    puts "in #{yellow(path)}"
    Dir.chdir(path) do
      sys("git add .")
      sys("git commit -m \"upgrade submodules\"")
    end
  end
end

desc "convert pngs to loseless jpgs"
task :strip do
  require_rmagick!
  
  Dir.glob(File.join(WWW, 'shared', "img", "*.png")) do |file|
    next unless file =~ /body-repeat/
    puts file
    image = ImageList.new(file)
    image.strip!
    image.write(file) #{ self.quality = 100; }
  end
end

desc "convert pngs to loseless jpgs"
task :print do
  require_rmagick!

  Dir.glob(File.join(WWW, 'shared', "img", "*.png")) do |file|
    next unless file =~ /tabs-background/
    puts file
        
    img = Magick::Image::read(file).first
    puts "   Format: #{img.format}"
    puts "   Geometry: #{img.columns}x#{img.rows}"
    puts "   Class: " + case img.class_type
      when Magick::DirectClass
        "DirectClass"
      when Magick::PseudoClass
        "PseudoClass"
    end
    puts "   Depth: #{img.depth} bits-per-pixel"
    puts "   Colors: #{img.number_colors}"
    puts "   Filesize: #{img.filesize}"
    puts "   Resolution: #{img.x_resolution.to_i}x#{img.y_resolution.to_i} "+"pixels/#{img.units == Magick::PixelsPerInchResolution ? "inch" : "centimeter"}"
    if img.properties.length > 0
      puts "   Properties:" 
      img.properties { |name,value| puts %Q|      #{name} = "#{value}"| }
    end
  end
end

desc "convert icons to other formats"
task :icons do
  require_rmagick!
  
  Dir.glob(File.join(WWW, 'shared', "img", "icons", "totalspaces-512.png")) do |file|
    puts file
    image = ImageList.new(file)

    file64 = file.gsub('512', '64')
    image64 = image.resize(64, 64)
    image64.write(file64)

    file128 = file.gsub('512', '128')
    image128 = image.resize(128, 128)
    image128.write(file128)

    file256 = file.gsub('512', '256')
    image256 = image.resize(256, 256)
    image256.write(file256)
        
    file512white = file.gsub('512', '512-white')
    bg = Image.new(image.columns, image.rows) {
      self.background_color = "white"
    }
    bg = bg.composite(image, CenterGravity, OverCompositeOp)
    bg.write(file512white)

    file256white = file.gsub('512', '256-white')
    bg = Image.new(image.columns, image.rows) {
      self.background_color = "white"
    }
    bg = bg.composite(image, CenterGravity, OverCompositeOp)
    bg = bg.resize(256, 256)
    bg.write(file256white)
  end
end

desc "optimize png images"
task :optimize do
  Dir.glob(File.join(WWW, 'shared', "**", "*.png")) do |file|
    puts file
    `optipng −i1 −o7 "#{file}"`
    break
  end
  Dir.glob(File.join(WWW, 'images', "**", "*.png")) do |file|
    puts file
    `optipng −i1 −o7 "#{file}"`
    break
  end
end

task :default => :serve